"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPackageLicAndAccessInfo = exports.getQuestionsAndAnswers = exports.cloneRepo = exports.getTemplateFolder = void 0;
const shell = __importStar(require("shelljs"));
const prompt_1 = require("./prompt");
const path_1 = require("path");
const mkdirp_1 = require("mkdirp");
const os_1 = require("os");
const fs = __importStar(require("fs"));
const dargs = require('dargs');
const getTemplateFolder = async (argv) => {
    let folderName = 'templates';
    // get example info
    if (argv.examples || argv.example || argv.ex) {
        folderName = 'examples';
        const example = argv.examples || argv.example || argv.ex;
        if (typeof example === 'string') {
            argv.template = example;
        }
    }
    // get boilerplate info
    if (argv.boilerplates || argv.boilerplate) {
        folderName = 'boilerplates';
        const boilerplate = argv.boilerplates || argv.boilerplate;
        if (typeof boilerplate === 'string') {
            argv.template = boilerplate;
        }
    }
    return folderName;
};
exports.getTemplateFolder = getTemplateFolder;
const cloneRepo = (argv, repo, name) => {
    const tempname = Math.random().toString(36).slice(2, 7);
    const dir = (0, path_1.join)(argv.tmpdir || (0, os_1.tmpdir)(), tempname);
    (0, mkdirp_1.sync)(dir);
    shell.cd(dir);
    // Initialize the command arguments in an array
    let gitCloneArgs = ['git', 'clone', '--depth', '1'];
    // Add the branch argument if argv.fromBranch is provided
    if (argv.fromBranch) {
        gitCloneArgs.push('-b', argv.fromBranch);
    }
    // Add the repository and name arguments
    gitCloneArgs.push(repo, name);
    // Join the arguments with spaces to form the command
    const gitCloneCommand = gitCloneArgs.join(' ');
    shell.exec(gitCloneCommand);
    return dir;
};
exports.cloneRepo = cloneRepo;
const getQuestionsAndAnswers = async (argv, name, folderName) => {
    const path = (0, path_1.join)(folderName, argv.template, '.questions.json');
    if (fs.existsSync(path)) {
        const questions = JSON.parse(fs.readFileSync(path, 'utf-8'));
        const fullname = shell
            .exec('git config --global user.name', { silent: true })
            .trim();
        const email = shell
            .exec('git config --global user.email', { silent: true })
            .trim();
        // @__USERNAME__/__MODULENAME__
        // __PACKAGE_IDENTIFIER__
        const args = dargs({
            _: [],
            ...argv,
            __QUESTIONS_EXIST_: true,
            __MODULENAME__: name,
            __USERFULLNAME__: fullname,
            __USEREMAIL__: email,
        }, { allowCamelCase: true });
        const results = await (0, prompt_1.prompt)(questions, args);
        return results;
    }
    else {
        return {};
    }
};
exports.getQuestionsAndAnswers = getQuestionsAndAnswers;
const getPackageLicAndAccessInfo = async (results) => {
    let scopedResults;
    const license = await (0, prompt_1.prompt)([
        {
            name: '__LICENSE__',
            message: 'Which license?',
            choices: ['MIT', 'closed'],
            type: 'list',
            required: true,
        },
    ], []);
    if (results.__ACCESS__ === 'public') {
        scopedResults = await (0, prompt_1.prompt)([
            {
                type: 'confirm',
                name: 'scoped',
                message: 'use npm scopes?',
                required: true,
            },
        ], []);
    }
    return {
        license,
        scopedResults
    };
};
exports.getPackageLicAndAccessInfo = getPackageLicAndAccessInfo;
//# sourceMappingURL=utils.js.map